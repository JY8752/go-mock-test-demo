// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package random

import (
	"sync"
)

// Ensure, that RandGeneratorMock does implement RandGenerator.
// If this is not the case, regenerate this file with moq.
var _ RandGenerator = &RandGeneratorMock{}

// RandGeneratorMock is a mock implementation of RandGenerator.
//
//	func TestSomethingThatUsesRandGenerator(t *testing.T) {
//
//		// make and configure a mocked RandGenerator
//		mockedRandGenerator := &RandGeneratorMock{
//			IntNFunc: func(n int) int {
//				panic("mock out the IntN method")
//			},
//		}
//
//		// use mockedRandGenerator in code that requires RandGenerator
//		// and then make assertions.
//
//	}
type RandGeneratorMock struct {
	// IntNFunc mocks the IntN method.
	IntNFunc func(n int) int

	// calls tracks calls to the methods.
	calls struct {
		// IntN holds details about calls to the IntN method.
		IntN []struct {
			// N is the n argument value.
			N int
		}
	}
	lockIntN sync.RWMutex
}

// IntN calls IntNFunc.
func (mock *RandGeneratorMock) IntN(n int) int {
	callInfo := struct {
		N int
	}{
		N: n,
	}
	mock.lockIntN.Lock()
	mock.calls.IntN = append(mock.calls.IntN, callInfo)
	mock.lockIntN.Unlock()
	if mock.IntNFunc == nil {
		var (
			nOut int
		)
		return nOut
	}
	return mock.IntNFunc(n)
}

// IntNCalls gets all the calls that were made to IntN.
// Check the length with:
//
//	len(mockedRandGenerator.IntNCalls())
func (mock *RandGeneratorMock) IntNCalls() []struct {
	N int
} {
	var calls []struct {
		N int
	}
	mock.lockIntN.RLock()
	calls = mock.calls.IntN
	mock.lockIntN.RUnlock()
	return calls
}
