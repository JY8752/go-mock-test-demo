// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repository

import (
	"go-mock-test-demo/tx"
	"sync"
)

// Ensure, that UserItemMock does implement UserItem.
// If this is not the case, regenerate this file with moq.
var _ UserItem = &UserItemMock{}

// UserItemMock is a mock implementation of UserItem.
//
//	func TestSomethingThatUsesUserItem(t *testing.T) {
//
//		// make and configure a mocked UserItem
//		mockedUserItem := &UserItemMock{
//			CreateWithTxFunc: func(txMoqParam tx.Transaction, userId int64, itemId int64) error {
//				panic("mock out the CreateWithTx method")
//			},
//			ExistFunc: func(userId int64, itemId int64) (bool, error) {
//				panic("mock out the Exist method")
//			},
//			IncrementCountWithTxFunc: func(txMoqParam tx.Transaction, userId int64, itemId int64) error {
//				panic("mock out the IncrementCountWithTx method")
//			},
//		}
//
//		// use mockedUserItem in code that requires UserItem
//		// and then make assertions.
//
//	}
type UserItemMock struct {
	// CreateWithTxFunc mocks the CreateWithTx method.
	CreateWithTxFunc func(txMoqParam tx.Transaction, userId int64, itemId int64) error

	// ExistFunc mocks the Exist method.
	ExistFunc func(userId int64, itemId int64) (bool, error)

	// IncrementCountWithTxFunc mocks the IncrementCountWithTx method.
	IncrementCountWithTxFunc func(txMoqParam tx.Transaction, userId int64, itemId int64) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateWithTx holds details about calls to the CreateWithTx method.
		CreateWithTx []struct {
			// TxMoqParam is the txMoqParam argument value.
			TxMoqParam tx.Transaction
			// UserId is the userId argument value.
			UserId int64
			// ItemId is the itemId argument value.
			ItemId int64
		}
		// Exist holds details about calls to the Exist method.
		Exist []struct {
			// UserId is the userId argument value.
			UserId int64
			// ItemId is the itemId argument value.
			ItemId int64
		}
		// IncrementCountWithTx holds details about calls to the IncrementCountWithTx method.
		IncrementCountWithTx []struct {
			// TxMoqParam is the txMoqParam argument value.
			TxMoqParam tx.Transaction
			// UserId is the userId argument value.
			UserId int64
			// ItemId is the itemId argument value.
			ItemId int64
		}
	}
	lockCreateWithTx         sync.RWMutex
	lockExist                sync.RWMutex
	lockIncrementCountWithTx sync.RWMutex
}

// CreateWithTx calls CreateWithTxFunc.
func (mock *UserItemMock) CreateWithTx(txMoqParam tx.Transaction, userId int64, itemId int64) error {
	callInfo := struct {
		TxMoqParam tx.Transaction
		UserId     int64
		ItemId     int64
	}{
		TxMoqParam: txMoqParam,
		UserId:     userId,
		ItemId:     itemId,
	}
	mock.lockCreateWithTx.Lock()
	mock.calls.CreateWithTx = append(mock.calls.CreateWithTx, callInfo)
	mock.lockCreateWithTx.Unlock()
	if mock.CreateWithTxFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateWithTxFunc(txMoqParam, userId, itemId)
}

// CreateWithTxCalls gets all the calls that were made to CreateWithTx.
// Check the length with:
//
//	len(mockedUserItem.CreateWithTxCalls())
func (mock *UserItemMock) CreateWithTxCalls() []struct {
	TxMoqParam tx.Transaction
	UserId     int64
	ItemId     int64
} {
	var calls []struct {
		TxMoqParam tx.Transaction
		UserId     int64
		ItemId     int64
	}
	mock.lockCreateWithTx.RLock()
	calls = mock.calls.CreateWithTx
	mock.lockCreateWithTx.RUnlock()
	return calls
}

// Exist calls ExistFunc.
func (mock *UserItemMock) Exist(userId int64, itemId int64) (bool, error) {
	callInfo := struct {
		UserId int64
		ItemId int64
	}{
		UserId: userId,
		ItemId: itemId,
	}
	mock.lockExist.Lock()
	mock.calls.Exist = append(mock.calls.Exist, callInfo)
	mock.lockExist.Unlock()
	if mock.ExistFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.ExistFunc(userId, itemId)
}

// ExistCalls gets all the calls that were made to Exist.
// Check the length with:
//
//	len(mockedUserItem.ExistCalls())
func (mock *UserItemMock) ExistCalls() []struct {
	UserId int64
	ItemId int64
} {
	var calls []struct {
		UserId int64
		ItemId int64
	}
	mock.lockExist.RLock()
	calls = mock.calls.Exist
	mock.lockExist.RUnlock()
	return calls
}

// IncrementCountWithTx calls IncrementCountWithTxFunc.
func (mock *UserItemMock) IncrementCountWithTx(txMoqParam tx.Transaction, userId int64, itemId int64) error {
	callInfo := struct {
		TxMoqParam tx.Transaction
		UserId     int64
		ItemId     int64
	}{
		TxMoqParam: txMoqParam,
		UserId:     userId,
		ItemId:     itemId,
	}
	mock.lockIncrementCountWithTx.Lock()
	mock.calls.IncrementCountWithTx = append(mock.calls.IncrementCountWithTx, callInfo)
	mock.lockIncrementCountWithTx.Unlock()
	if mock.IncrementCountWithTxFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.IncrementCountWithTxFunc(txMoqParam, userId, itemId)
}

// IncrementCountWithTxCalls gets all the calls that were made to IncrementCountWithTx.
// Check the length with:
//
//	len(mockedUserItem.IncrementCountWithTxCalls())
func (mock *UserItemMock) IncrementCountWithTxCalls() []struct {
	TxMoqParam tx.Transaction
	UserId     int64
	ItemId     int64
} {
	var calls []struct {
		TxMoqParam tx.Transaction
		UserId     int64
		ItemId     int64
	}
	mock.lockIncrementCountWithTx.RLock()
	calls = mock.calls.IncrementCountWithTx
	mock.lockIncrementCountWithTx.RUnlock()
	return calls
}
